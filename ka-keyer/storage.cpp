#include "settings.hpp"
#include "storage.hpp"

#ifdef ARDUINO_AVR_NANO
#include "EEPROM.h"
#define EEPROM_SIZE 1024
#endif

#ifdef ARDUINO_WAVESHARE_RP2040_ZERO
#include "Wire.h"
#define EEPROM_ADDRESS 0x50
#define EEPROM_SIZE 256
#endif

#define EEPROM_SLOTS (EEPROM_SIZE / SETTINGS_PDATA_SIZE)

static uint8_t localData[SETTINGS_PDATA_SIZE];
static uint8_t currentSlot;
static uint8_t nextSlot;
static uint8_t bytesToWrite;
static unsigned long activationTime;
static unsigned long lastWrite;

static const uint8_t crcTable[256] PROGMEM = {
  0x00, 0x41, 0x13, 0x52, 0x26, 0x67, 0x35, 0x74, 0x4C, 0x0D, 0x5F, 0x1E, 0x6A, 0x2B, 0x79, 0x38,
  0x09, 0x48, 0x1A, 0x5B, 0x2F, 0x6E, 0x3C, 0x7D, 0x45, 0x04, 0x56, 0x17, 0x63, 0x22, 0x70, 0x31,
  0x12, 0x53, 0x01, 0x40, 0x34, 0x75, 0x27, 0x66, 0x5E, 0x1F, 0x4D, 0x0C, 0x78, 0x39, 0x6B, 0x2A,
  0x1B, 0x5A, 0x08, 0x49, 0x3D, 0x7C, 0x2E, 0x6F, 0x57, 0x16, 0x44, 0x05, 0x71, 0x30, 0x62, 0x23,
  0x24, 0x65, 0x37, 0x76, 0x02, 0x43, 0x11, 0x50, 0x68, 0x29, 0x7B, 0x3A, 0x4E, 0x0F, 0x5D, 0x1C,
  0x2D, 0x6C, 0x3E, 0x7F, 0x0B, 0x4A, 0x18, 0x59, 0x61, 0x20, 0x72, 0x33, 0x47, 0x06, 0x54, 0x15,
  0x36, 0x77, 0x25, 0x64, 0x10, 0x51, 0x03, 0x42, 0x7A, 0x3B, 0x69, 0x28, 0x5C, 0x1D, 0x4F, 0x0E,
  0x3F, 0x7E, 0x2C, 0x6D, 0x19, 0x58, 0x0A, 0x4B, 0x73, 0x32, 0x60, 0x21, 0x55, 0x14, 0x46, 0x07,
  0x48, 0x09, 0x5B, 0x1A, 0x6E, 0x2F, 0x7D, 0x3C, 0x04, 0x45, 0x17, 0x56, 0x22, 0x63, 0x31, 0x70,
  0x41, 0x00, 0x52, 0x13, 0x67, 0x26, 0x74, 0x35, 0x0D, 0x4C, 0x1E, 0x5F, 0x2B, 0x6A, 0x38, 0x79,
  0x5A, 0x1B, 0x49, 0x08, 0x7C, 0x3D, 0x6F, 0x2E, 0x16, 0x57, 0x05, 0x44, 0x30, 0x71, 0x23, 0x62,
  0x53, 0x12, 0x40, 0x01, 0x75, 0x34, 0x66, 0x27, 0x1F, 0x5E, 0x0C, 0x4D, 0x39, 0x78, 0x2A, 0x6B,
  0x6C, 0x2D, 0x7F, 0x3E, 0x4A, 0x0B, 0x59, 0x18, 0x20, 0x61, 0x33, 0x72, 0x06, 0x47, 0x15, 0x54,
  0x65, 0x24, 0x76, 0x37, 0x43, 0x02, 0x50, 0x11, 0x29, 0x68, 0x3A, 0x7B, 0x0F, 0x4E, 0x1C, 0x5D,
  0x7E, 0x3F, 0x6D, 0x2C, 0x58, 0x19, 0x4B, 0x0A, 0x32, 0x73, 0x21, 0x60, 0x14, 0x55, 0x07, 0x46,
  0x77, 0x36, 0x64, 0x25, 0x51, 0x10, 0x42, 0x03, 0x3B, 0x7A, 0x28, 0x69, 0x1D, 0x5C, 0x0E, 0x4F
};

static uint8_t getCRC(uint8_t *data, int length) {
  uint8_t crc = 0;
  for (int i = 0; i < length; i++){
    crc = pgm_read_byte(&crcTable[crc ^ *data++]);
  }
  return crc;
}

static void updateCRC(uint8_t *data){
  data[SETTINGS_PDATA_SIZE - 1] = getCRC(data, SETTINGS_PDATA_SIZE - 1);
}

#ifdef ARDUINO_AVR_NANO
static void eepromUpdate(int address, uint8_t data){
  EEPROM.update(address, data);
}
#endif

#ifdef ARDUINO_WAVESHARE_RP2040_ZERO

void storageBegin(uint8_t scl, uint8_t sda){
  Wire.setSCL(scl);
  Wire.setSDA(sda);
  Wire.begin();
  Wire.setClock(400000);
}

static void writeI2CByte(uint8_t data_addr, uint8_t data){
  Wire.beginTransmission(EEPROM_ADDRESS);
  Wire.write(data_addr);
  Wire.write(data);
  Wire.endTransmission();
}

static uint8_t readI2CByte(uint8_t data_addr){
  uint8_t data = 0;
  Wire.beginTransmission(EEPROM_ADDRESS);
  Wire.write(data_addr);
  Wire.endTransmission();
  Wire.requestFrom(EEPROM_ADDRESS, 1); //retrieve 1 returned byte
  if(Wire.available()){
    data = Wire.read();
  }
  return data;
}

static void eepromUpdate(int address, uint8_t data){
  uint8_t val = readI2CByte(address);
  if (val != data){
    writeI2CByte(address, data);
  }
}

static void eepromGet(int address, uint8_t *data){
  for (int n = 0; n < SETTINGS_PDATA_SIZE; n++){
    data[n] = readI2CByte(address + n);
  }
}

#endif

void storageLoad(uint8_t *data){
  // Look for a slot with valid CRC
  for (currentSlot = 0; currentSlot < EEPROM_SLOTS; currentSlot++) {
#ifdef ARDUINO_AVR_NANO    
    EEPROM.get(currentSlot * SETTINGS_PDATA_SIZE, localData);
#endif
#ifdef ARDUINO_WAVESHARE_RP2040_ZERO
    eepromGet(currentSlot * SETTINGS_PDATA_SIZE, localData);
#endif
    if (getCRC(localData, SETTINGS_PDATA_SIZE - 1) == localData[SETTINGS_PDATA_SIZE - 1]) {
      // Good CRC
      memcpy(data, localData, SETTINGS_PDATA_SIZE);
      break;
    }
  }

  if (currentSlot == EEPROM_SLOTS) {
    // For loop didn't find a valid slot. Point to
    // EEPROM_SLOTS - 1 so the first write will be at 0
    currentSlot = EEPROM_SLOTS - 1;
  }
}

void storageSave(uint8_t *data){
  // Make a local copy from the data to be saved
  memcpy(localData, data, SETTINGS_PDATA_SIZE);

  //update CRC
  updateCRC(localData);

  activationTime = millis();

  lastWrite = activationTime;
  
  nextSlot = (currentSlot + 1) % EEPROM_SLOTS;

  bytesToWrite = SETTINGS_PDATA_SIZE + 1;
}

void storageProcess(){
  unsigned long now;
  if (bytesToWrite){
    now = millis();
    if ((now - activationTime) > 10000) { // Ten seconds
      if ((now - lastWrite) > 10) { // 10ms between writes
        if(bytesToWrite == 1){
          // Invalidates current slot CRC
          eepromUpdate((currentSlot * SETTINGS_PDATA_SIZE) + (SETTINGS_PDATA_SIZE - 1), 0xFF);
          // Point to next slot
          currentSlot = nextSlot;
        } else {
          eepromUpdate((nextSlot * SETTINGS_PDATA_SIZE) + (bytesToWrite - 2), localData[bytesToWrite - 2]);
        }
        bytesToWrite--;
        lastWrite = now;
      }
    }
  }
}
